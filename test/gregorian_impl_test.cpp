#include "calendar_types.h"
#include "gregorian_impl.h"
#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <tuple>
#include <vector>

using namespace testing;
using CallArgs = std::tuple<std::string, size_t, size_t, size_t, size_t>;

class GregorianImplTests : public testing::Test {

  public:
    static inline std::vector<CallArgs> expectedCalls;
    static inline MonthData dummyData = {{CellType::Label, "D"},
                                         {CellType::Label, "u"},
                                         {CellType::Label, "m"},
                                         {CellType::Label, "m"},
                                         {CellType::Label, "y"}};
};

// GregorianImpl uses type injection rather than dependency injection (we only injected
// the type of the dependency, not the dependency itself). So, we cannot
// set the expectations in the test itself, but we can do so in the mock.
class MockMonth {

  public:
    explicit MockMonth(const Properties &params) {
        // Expections will be set based on the state
        // of expectedCalls at the time that the mock object is created.

        // The data returned will be just the passed in month name and an empty vector
        for (auto &callParameters : GregorianImplTests::expectedCalls) {
            EXPECT_CALL(*this, functionOperatorMock(
                                   std::get<0>(callParameters), std::get<1>(callParameters),
                                   std::get<2>(callParameters), std::get<3>(callParameters),
                                   std::get<4>(callParameters)))
                .Times(1)
                .WillOnce(
                    Return(Month{std::get<0>(callParameters), GregorianImplTests::dummyData}));
        }
    }

    // Needed so that we can set expectations
    MOCK_METHOD(Month, functionOperatorMock,
                (const std::string &monthName, size_t dateStart, size_t dateEnd,
                 size_t monthStartDayIndex, size_t weekNumber),
                (const));

    // We cannot mock the function operator directly - it must be defined by a pass-through
    Month operator()(const std::string &monthName, size_t dateStart, size_t dateEnd,
                     size_t monthStartDayIndex, size_t weekNumber) const {
        return functionOperatorMock(monthName, dateStart, dateEnd, monthStartDayIndex, weekNumber);
    }
};

TEST_F(GregorianImplTests, populateMonths) {
    // This is not an integration test: We seek to verify that the calls made on the object of the
    // injected type are rigourously correct according to the Gregorian calendar, and that the
    // function returns the objects generated by MonthType, unaltered.

    GregorianImpl<MockMonth> testImplementation;

    // The return is just dummy data, the year paired with a vector of named dummy months.
    auto makeDummyYear = [](size_t year) {
        Year expectedYear{year, YearData()};
        for (const auto &monthCall : expectedCalls) {
            expectedYear.second.emplace_back(std::get<0>(monthCall), GregorianImplTests::dummyData);
        }
        return expectedYear;
    };

    // Set mock objects to expect calls associated with 2024 - a leap year.
    expectedCalls = {
        {"January", 1, 31, 0, 1},  {"February", 1, 29, 3, 5},  {"March", 1, 31, 4, 9},
        {"April", 1, 30, 0, 14},   {"May", 1, 31, 2, 18},      {"June", 1, 30, 5, 22},
        {"July", 1, 31, 0, 27},    {"August", 1, 31, 3, 31},   {"September", 1, 30, 6, 35},
        {"October", 1, 31, 1, 40}, {"November", 1, 30, 4, 44}, {"December", 1, 31, 6, 48},
    };
    auto expectedReturn2024 = makeDummyYear(2024);

    auto returnValue2024 = testImplementation.populateYear(2024);
    EXPECT_EQ(returnValue2024, expectedReturn2024);

    // Set mock objects to expect calls associated with 2023 - a non leap year.
    expectedCalls = {
        {"January", 1, 31, 6, 1},  {"February", 1, 28, 2, 6},  {"March", 1, 31, 2, 10},
        {"April", 1, 30, 5, 14},   {"May", 1, 31, 0, 19},      {"June", 1, 30, 3, 23},
        {"July", 1, 31, 5, 27},    {"August", 1, 31, 1, 32},   {"September", 1, 30, 4, 36},
        {"October", 1, 31, 6, 40}, {"November", 1, 30, 2, 45}, {"December", 1, 31, 4, 49},
    };
    auto expectedReturn2023 = makeDummyYear(2023);

    auto returnValue2023 = testImplementation.populateYear(2023);
    EXPECT_EQ(returnValue2023, expectedReturn2023);
}

// Test the sub functions for completeness
TEST_F(GregorianImplTests, helperFunctions) {
    GregorianImpl<MockMonth> testImplementation;

    // Supply a range of test years, whether they are leap and what day they start on.
    auto testParameters = std::vector<std::tuple<size_t, bool, size_t>>{
        {1900, false, 0}, {2000, true, 5}, {2001, false, 0}, {2004, true, 3}};

    for (const auto [testYear, expectedLeapYear, yearStartIndex] : testParameters) {
        EXPECT_EQ(testImplementation.isLeapYear(testYear), expectedLeapYear);
        EXPECT_EQ(testImplementation.getBaseIndex(testYear), yearStartIndex);
    }

    // For Gregorian validation, there are three categories of month:
    // 1) Before the start of the Gregorian Calendar on 15th October 1582, e.g. September 1582
    // 2) The month of the Gregorian Calendar start, e.g. October 1582
    // 3) After the Gregorian Calendar Start, e.g. November 1582 onward

    // Corresponding to expected output:
    // 1) A start of range greater than the end of the range, the precise values being unimportant
    // 2) The Gregorian month Oct 1582 starts on the 15th and ends on the 31
    // 3) everything after that starts on day 1 and ends whenever we said it would end.

    auto january1581 = testImplementation.validate(1581, 0, 31);
    EXPECT_LT(january1581.second, january1581.first);

    auto september1582 = testImplementation.validate(1582, 8, 30);
    EXPECT_LT(september1582.second, september1582.first);

    auto october1582 = testImplementation.validate(1582, 9, 31);
    EXPECT_EQ(october1582.first, 15);
    EXPECT_EQ(october1582.second, 31);

    auto november1582 = testImplementation.validate(1582, 10, 30);
    EXPECT_EQ(november1582.first, 1);
    EXPECT_EQ(november1582.second, 30);

    auto january1583 = testImplementation.validate(1583, 0, 31);
    EXPECT_EQ(january1583.first, 1);
    EXPECT_EQ(january1583.second, 31);
}
